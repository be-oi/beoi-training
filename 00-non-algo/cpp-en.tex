\documentclass[12pt]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{listings,tabu,tikz,amsmath,xcolor,textcomp}
\usepackage[english]{babel}

\definecolor{myblue}{rgb}{0,0,0.7}
\definecolor{mygreen}{rgb}{0,0.5,0}
\definecolor{mygray}{rgb}{0.4,0.4,0.4}
\definecolor{mymauve}{rgb}{0.3,0,0.5}

\lstset{
    language=C++, basicstyle=\footnotesize, frame=single,
    literate=%
        {à}{{\`a}}1
        {â}{{\^a}}1
        {É}{{\'E}}1 {é}{{\'e}}1
        {è}{{\`e}}1
        {ê}{{\^e}}1
        {î}{{\^i}}1,
    commentstyle=\color{mygreen},
    keywordstyle=\bf\color{myblue},
    stringstyle=\color{mymauve},
    showstringspaces=false
}

\beamertemplatenavigationsymbolsempty
\AtBeginSection[]
{
    \begin{frame}
    \frametitle{Table of contents}
    \tableofcontents[currentsection]
    \end{frame}
}

\title{Crash course in C++}
\subtitle{}
\author{beOI Training}
\institute{\includegraphics[height=12em]{../share/beoi-logo}}
\date{}

\begin{document}

\maketitle


\section{The basics}

\begin{frame}[fragile]
\frametitle{Hello world!}
\begin{lstlisting}
// This is a comment
#include <bits/stdc++.h> // imports STL library
using namespace std; // avoids writing "std::"

// Function declaration: type name() { [...] }
int main() {
    // All instructions end with ";"
    cout << "Hello World!" << endl;
    // endl = new line
}
\end{lstlisting}
\begin{itemize}
\item The function \lstinline|int main()| is called when starting the program.
\item \lstinline|int| means that \lstinline|main()| returns an integer, but \lstinline|main()| automatically returns \lstinline|0| (historical reasons).
\item The direction of \lstinline|<<| indicates that the words are sent to \lstinline|cout|, the "standard output".
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Compiling and runing}
C++ programs first have to be "translated" into a language that the computer can understand.

~

\textbf{Compiling} (through the command line)
\begin{lstlisting}
g++ -std=c++11 -Wall -Wextra -Wshadow hello.cpp
\end{lstlisting}
\begin{itemize}
\item \lstinline|g++|: compiler name
\item \lstinline|-std=c++11|: used C++ version
\item \lstinline|-Wall -Wextra -Wshadow|: activates many useful warnings that help identify bugs
\item \lstinline|hello.cpp|: source code
\end{itemize}

\textbf{Running}: \lstinline|./a.out|
\begin{itemize}
\item \lstinline|./|: current folder
\item \lstinline|a.out|: name of the executable generated by \lstinline|g++|.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Variables and operations}
We must specify a type for every variable
\begin{lstlisting}
int i = 5; // integers in range [-2^31, 2^31[
double j = 5.4; // number with commas
bool b = true; // boolean (true or false)
char ch = 'D'; // single character
string s = "abcd"; // multiple characters

// We can also initialize the variables later
int k,l; // declare multiple variables
         // of the same type

k = i + 2;
l = 7 / 3; // integer division => l = 2
s += ch; // appending a character
j /= 3; // dividing j by 3
i++; l--; // adding 1, subtracting 1
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Conditionals}
\begin{lstlisting}
int age;
cout << "How old are you? ";
cin >> age; // reading input
if (age < 18)
    cout << "You are underage." << endl;
else if (age <= 120)
    cout << "You are an adult." << endl;
else {
    int a=3, b=4, c=5;
    bool rectangle = (a*a + b*b == c*c);
    if (rectangle && !(a == 0 || b == 0))
        cout << "Hypotenuse = " << c << endl;
}
\end{lstlisting}
\begin{itemize}
\item Curly braces \lstinline|{}| are optional if writing a single line in the if/else/loop
\item The direction of \lstinline|>>| indicates that the integer comes from \lstinline|cin|, the "standard input".
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Loops}
\begin{lstlisting}
// Print numbers from 1 to 5
for (int i=1; i<=5; i++)
    cout << i << endl;

string s; // initially empty
while (s != "yes") { // != means "not equal"
    cout << "Do you like programming? ";
    cin >> s;
}
\end{lstlisting}
\begin{itemize}
\item \lstinline|for(;;)| loops have 3 parts:
\begin{itemize}
\item Initialisation: initialise one or more variables
\item Condition: the loops stops when the condition becomes false
\item Incrementation: executed at the end of each interation
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Functions}
\begin{lstlisting}
// Must specify return and parameters type
int square(int x) {
    return x*x;
}
void sayHello(string s) { // void = return nothing
    cout << "Hello " << s << endl;
}
int main() {
    int y = square(4); // y = 16
    sayHello("Victor");
}
\end{lstlisting}
\begin{itemize}
\item Can't be nested and always placed \emph{before} their call. Otherwise, you can declare them like this: \lstinline|void sayHello(string s);| and implement them later on.
\item When a function is not \lstinline|void|, all executions have to end with a \lstinline|return|.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Arrays}
All elements of an array must have the same type.
\begin{lstlisting}
int maxi(int tab[], int n) { // [] is alywas after
    int ma = 0;              // the name
    for (int i=0; i<n; i++)
        ma = max(ma, tab[i]);
    return ma; // returns the maximum from tab
}
int main() {
    int a[5], b[4][3]; // 4 rows and 3 columns
    for (int i=0; i<5; i++)
        cin >> a[i];
    cout << maxi(a, 5) << endl;
}
\end{lstlisting}
\begin{itemize}
\item The first element has index \lstinline|[0]|.
\item The size can't be modified.
\item An array doesn't know its size! We have to pass it separately when calling a function.
\end{itemize}
\end{frame}


\section{The standard library}

\begin{frame}[fragile]
\frametitle{STL and containers}
The standard library (STL) contains many useful structures and functions.

~

A very useful structure is the \lstinline|vector<>|:
\begin{lstlisting}
vector<int> v(3,-1); // 3 elements set to -1
v.push_back(7); // adding 7 to the vector
v[1] = 5; // access it like an array
for (int i : v) // iterate over elements
    cout << i << endl; // prints -1, 5, -1, 7
\end{lstlisting}
\begin{itemize}
\item We specify the element type between "$<>$": \lstinline|<int>|.
\item Structures have constructors that initialise them (here \lstinline|(3,-1)|) an many methods (here \lstinline|.push_back()|).
\item More info about containers: \url{http://en.cppreference.com/w/cpp/container}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{STL algorithms}
STL also has many algorithms ready to use:
\begin{lstlisting}
vector<int> v{4,-1,3,2}; // initialise a vector
sort(v.begin(), v.end()); // sort a vector
swap(v[0], v[1]); // swap the contents
reverse(v.begin(), v.end()); // reverse the vector

for (int i : v)
    cout << v << endl; // print 4, 3, -1, 2
\end{lstlisting}
\begin{itemize}
\item And many others: copy, binary search, matching, selecting the $i$-the smallest element, ...
\item More info about STL algorithms: \url{http://en.cppreference.com/w/cpp/algorithm}
\end{itemize}
\end{frame}


\section{Pointers and references}

\begin{frame}
\frametitle{Disclaimer}
Beware: it gets hard from now on.

~

But nothing is too hard for you :)
\end{frame}

\begin{frame}[fragile]
\frametitle{Memory and addresses}
The memory of a PC is like a big array, filled with compartments for memorising the variables.
\vspace{6pt}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\textbf{Program}
\begin{lstlisting}
...
int a = 2, b = 3;
char ch[]{'h','e','y'};
...
\end{lstlisting}
\end{column}
\begin{column}{.45\textwidth}
\textbf{RAM Memory}
\vspace{4pt}

\begin{tabu} {r|c|c|c|c|}
$\cdots$ & \multicolumn{4}{c|}{$\cdots$} \\
\cline{2-5}
\lstinline|mem[12]| & \multicolumn{4}{c|}{\lstinline|a = 2|} \\
\cline{2-5}
\lstinline|mem[8]| & \multicolumn{4}{c|}{\lstinline|b = 3|} \\
\cline{2-5}
\lstinline|mem[4]| & \lstinline|'h'| & \lstinline|'e'| & \lstinline|'y'| & \\
\cline{2-5}
$\cdots$ & \multicolumn{4}{c|}{$\cdots$}
\end{tabu}
\end{column}
\end{columns}
\vspace{4pt}

\begin{itemize}
\item Each compartment can contain a byte (8 bits), and a variable can spread over a few compartments (\lstinline|int| 4, \lstinline|double| 8)
\item Every compartment has an \emph{address} (\lstinline|4|, \lstinline|8|, \lstinline|12|, ...).
\item The address lets us access the variable
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pointers}
\begin{itemize}
\item A pointer is a variable that contains the address of another variable.
\item We can read or modify a variable using its pointer.
\end{itemize}
\vspace{6pt}
\begin{columns}[T]
\begin{column}{.6\textwidth}
\textbf{Programme}
\begin{lstlisting}
int a = 2;
int *b = &a; // type = (int *)
cout << b << endl;  // 12
cout << *b << endl; // 2
*b = 5; // modifies a, pas b
cout << a << endl;  // 5
\end{lstlisting}
\end{column}
\begin{column}{.3\textwidth}
\textbf{RAM Memory}
\vspace{7pt}

\begin{tabu}{r|c|}
$\cdots$ & $\cdots$ \\
\cline{2-2}
\lstinline|mem[12]| & \lstinline|a = 2| \\
\cline{2-2}
\lstinline|mem[8]| & \lstinline|b = 12| \\
\cline{2-2}
$\cdots$ & $\cdots$
\end{tabu}
\end{column}
\end{columns}
\vspace{3pt}
\begin{itemize}
\item \lstinline|&a| = ``index of \lstinline|a| in \lstinline|mem[]|''
\item \lstinline|*b| = \lstinline|mem[b]| (we can write there)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Passing a pointer}
\begin{itemize}
\item When we pass a variable to a function, it is copied (passing \emph{a value}).
\item \emph{If we modify it, it doesn't change the original variable.}
\end{itemize}
\vspace{3pt}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\textbf{Passing a value}
\begin{lstlisting}
void add3(int a) {
    a += 3;
}   // a = copy of i
int main() {
    int i=2;
    add3(i);
    cout << i << endl;
}   // prints 2
\end{lstlisting}
\end{column}
\begin{column}{.45\textwidth}
\textbf{Passing a pointer}
\begin{lstlisting}
void add3(int *p) {
    *p += 3;
}   // "mem[p] += 3"
int main() {
    int i=2;
    add3(&i);
    cout << i << endl;
}   // prints 5
\end{lstlisting}
\end{column}
\end{columns}
\vspace{3pt}
On the right side, the address \lstinline|p| itself is passed by value, \emph{but we modify the value of \lstinline|i| directly from memory using \lstinline|*p|}.
\end{frame}

\begin{frame}[fragile]
\frametitle{References}
References let you disguise a pointer as a normal variable (you use it without having to write \lstinline|&| and \lstinline|*|).
\begin{lstlisting}
int a = 2;
int &b = a; // type = (int &)
cout << b << endl;  // 2
b = 5; // modifies a through b
cout << a << ' ' << b << endl;  // 5 5
\end{lstlisting}
Differences with pointers:
\begin{itemize}
\item A reference can only be linked to a single variable (and can't be changed afterwards).
\item \lstinline|b| is just like another name for \lstinline|a|, it's an alias.
\item We can't access the address of \lstinline|a|.
\item The \lstinline|&| used to declare references \textbf{doesn't have anything to do} with the \lstinline|&| of pointers.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Passing a reference}
When we pass a variable as \emph{a reference}, it is not copied, it is the "same variable".
\vspace{3pt}
\begin{columns}[T]
\begin{column}{.45\textwidth}
\textbf{Passing a value}
\begin{lstlisting}
void add3(int a) {
    a += 3;
}   // a = copy of i
int main() {
    int i=2;
    add3(i);
    cout << i << endl;
}   // prints 2
\end{lstlisting}
\end{column}
\begin{column}{.45\textwidth}
\textbf{Passing a reference}
\begin{lstlisting}
void add3(int &a) {
    a += 3;
}   // a = alias of i
int main() {
    int i=2;
    add3(i);
    cout << i << endl;
}   // prints 5
\end{lstlisting}
\end{column}
\end{columns}
\vspace{3pt}
\begin{itemize}
\item The only syntax difference is the \lstinline|&| in front of the variable name.
\item On the right side, since \lstinline|i| and \lstinline|a| are 2 names for one same variable, when we modify \lstinline|a|, \lstinline|i| also gets modified.
\item We avoid copying the variable $\Rightarrow$ much faster.
\end{itemize}
\end{frame}

\end{document}
